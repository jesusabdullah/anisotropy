\chapter{Numerical Needle Probe Approach}
\label{sec:numerical-np}
\bigskip

\section{Introduction} 
\label{sec:numerical-np:introduction}

Numerical experiments simulated needle probes in anisotropic mediums with
three-dimensional finite element heat transfer models in COMSOL 3.5a. While the
models themselves were relatively simple, attempting to automate a parameter
study in COMSOL 3.5a with respect to the anisotropic material properties proved
difficult.

\section{Geometry and Domain Properties}
\label{sec:numerical-np:domain}

\begin{table}[h]
\label{tab:constants}
\centering
\caption{Constants Used in Numerical Models}
\begin{tabular}{r | l}
radius of needle & \(0.25\) mm\\
length of needle & \(10\) cm\\
radius of snow & \(40\) cm\\
\hline
density of needle & \(8000\) kg/\(\textrm{m}^3\)\\
\(C_P\) of needle & \(460\) \textbf{*units*}\\
\(q\) of needle & \(0.5\) W/m\\
\(k\) of needle & \(160\) \textbf{*units*}\\
\hline
density of snow & \(200\) kg/\(\textrm{m}^3\)\\
\(C_P\) of snow & \(2050\) \textbf{*units*}
\end{tabular}
\end{table}

The needle was simulated as a long, thin steel cylinder embedded in the center
of a sphere of snow. While most of the dimensions and material properties were
held constant (see Table \ref{tab:constants}), the anisotropic conductivity of
the snow was parameterized in the form of a \(3\times3\) symmetric, positive
definite matrix.  In practice, this was done by specifying a diagonal matrix
\(\Lambda\) with positive eigenvalues \(k_{xy}\) and \(k_z\) and a rotation
matrix \(R\) around the \(x\) axis, and then defining \(K = R^T\Lambda R\) as in
equation \ref{eq:rotdiagrot} :

\begin{equation}
\label{eq:rotdiagrot}
K = \begin{bmatrix}
\cos(\theta) & 0 & \sin(\theta)\\
0 & 1 & 0\\
-\sin(\theta) & 0 &\cos(\theta)
\end{bmatrix}
\begin{bmatrix}
k_{xy} & 0 & 0\\
0 & k_{xy} & 0\\
0 & 0 & k_z
\end{bmatrix}
\begin{bmatrix}
\cos(\theta) & 0 & \sin(\theta)\\
0 & 1 & 0\\
-\sin(\theta) & 0 &\cos(\theta)
\end{bmatrix}
\end{equation}

The boundary conditions on the surface of the sphere enforced zero heat flux,
and the radius of the sphere was chosen such that the sphere approximated an
infinite medium.

Point temperatures recorded were the center of the needle, which corresponds to
the location of the thermocouple used in real-world experiments, and six points
on the surface of the snow, to ensure that the sphere was sufficiently large.

\section{MATLAB in Geometry-Based Parameter Studies Using COMSOL 3.5a}
\label{sec:numerical-np:matlab}

Unfortunately, COMSOL 3.5a did not have the facilities necessary to implement a
geometry-changing multi-parameter study as required from the GUI alone. However,
COMSOL 3.5a did have facilities for scripting with MATLAB. Unfortunately, I
found the facility to be poorly-documented, and, at least with the particular
install hosted by ARSC, buggy and prone to crashing.

MATLAB code written to implement the parameter study was largely auto-generated
by COMSOL, by building a base model in COMSOL 3.5a and exporting to an m-file.
This code was then split into two parts: The meshing code, and the solving code.
These pieces of code were wrapped in functions, called ``mesher'' and ``solver''
respectively, and used by a main procedure called ``worker.m.'' Contained in
``worker.m'' is a MATLAB structure with the constants outlined in section
\ref{sec:numerical-np:domain} called ``params'':

\small
\begin{minted}{matlab}
    params=struct('rsnow', 0.4, ...
                  'rneedle', 0.00025, ...
                  'lneedle', 0.1, ...
                  'density_snow', 200, ...
                  'density_needle', 8000, ...
                  'cp_snow', 2050, ...
                  'cp_needle', 460, ...
                  'q_needle', 0.5, ...
                  'k_needle', 160, ...
                  'time', [logspace(0.1,1,15) logspace(1,3,15)], ...
                  'angles', angles );
\end{minted}
\normalsize

This structure also contains a list of angles yet to be solved for, and the
times for which to solve.

The meshing code was wrapped in a function called ``mesher'' and took an angle
(in degrees) and the params structure as arguments, and is for the most part
simply code generated by COMSOL:

%% MESHER %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\small
\begin{minted}{matlab}

% COMSOL Multiphysics Model M-file
% Generated in part by COMSOL 3.5a (COMSOL 3.5.0.608, $Date: 2009/05/11 07:38:49 $)
% the rest of it modified by Joshua Holbrook

function fem=mesher(angle,params)
    % mesh_generate(angle)
    % generates a mesh for the given angle. 

    fprintf(['meshing for angle=' num2str(angle) '...\n']);

    flclear fem

    % COMSOL version
    clear vrsn
    vrsn.name = 'COMSOL 3.5';
    vrsn.ext = 'a';
    vrsn.major = 0;
    vrsn.build = 608;
    vrsn.rcs = '$Name: v35ap $';
    vrsn.date = '$Date: 2009/05/11 07:38:49 $';
    fem.version = vrsn;
\end{minted}
\normalsize

The COMSOL code was changed to use the arguments passed to ``mesher'' instead of
the values used in the original model:

\small
\begin{minted}{matlab}
    % Geometry
    g1=sphere3(num2str(params.rsnow),'pos',{'0','0','0'},'axis',{'0','0','1'},'rot','0');
    g2=cylinder3(num2str(params.rneedle),num2str(params.lneedle),'pos',{num2str(-params.lneedle/2),'0','0'},'axis',{'1','0','0'},'rot','0');
    parr={point3(0,0,0)};
    g3=geomcoerce('point',parr);
    parr={point3(params.rsnow,0,0)};
    g4=geomcoerce('point',parr);
    parr={point3(0,params.rsnow,0)};
    g5=geomcoerce('point',parr);
    parr={point3(0,0,params.rsnow)};
    g6=geomcoerce('point',parr);
    parr={point3(-params.rsnow,0,0)};
    g7=geomcoerce('point',parr);
    parr={point3(0,-params.rsnow,0)};
    g8=geomcoerce('point',parr);
    parr={point3(0,0,-params.rsnow)};
    g9=geomcoerce('point',parr);
\end{minted}
\normalsize

Here, it can be seen that a number of points are generated: First, the point
representing the thermocouple temperature at \((0, 0, 0)\), and then six points
over the surface of the sphere.

Notice that, in this code, ``theta'' is never actually used. This is
because, in early iterations of the code, the needle was rotated by the angle
``theta.'' However, this seemed to cause random errors from COMSOL's meshing
procedures, so the anisotropic thermal properties of the snow were changed
instead, as outlined in section \ref{sec:numerical-np:domain}. However, the
argument was retained in order to avoid editing other legacy code in the model.

Afterwards, geometry is labelled and a mesh is initialized and refined using
code generated by COMSOL, and returns the COMSOL ``fem'' structure:

\small
\begin{minted}{matlab}

    % Analyzed Geometry
    clear p s
    p.objs={g3,g4,g5,g6,g7,g8,g9};
    p.name={'ORIGIN','PT1','PT2','PT3','PT4','PT5','PT6'};
    p.tags={'g3','g4','g5','g6','g7','g8','g9'};

    s.objs={g1,g2};
    s.name={'SNOW','NEEDLE'};
    s.tags={'g1','g2'};

    fem.draw=struct('p',p,'s',s);
    fem.geom=geomcsg(fem);


    % ODE Settings
    clear ode
    clear units;
    units.basesystem = 'SI';
    ode.units = units;
    fem.ode=ode;


    % Initialize mesh
    fem.mesh=meshinit(fem, ...
                      'hauto',5, ...
                      'hgradsub',[2,1.1], ...
                      'hmaxsub',[2,0.0005]);

    % Refine mesh
    fem.mesh=meshrefine(fem, ...
                        'mcase',0, ...
                        'rmethod','longest');

    fem=multiphysics(fem);
end
\end{minted}
\normalsize

This ``fem'' structure may then be passed to the ``solver'' function, along
with parameters describing the snow's material properties and the needle's
orientation with respect to the snow. Similarly, the ``solver'' function is
mostly COMSOL code wrapped in a function:

\small
\begin{minted}{matlab}
% COMSOL Multiphysics Model M-file
% Generated by COMSOL 3.5a (COMSOL 3.5.0.608, $Date: 2009/05/11 07:38:49 $)
% the rest of it modified by Joshua Holbrook

function answer=solver(kxy,kz,fem,theta,params)
    %solver(kxy,kz,mesh,theta,params)
    %uses comsol to pump out a solution using a given mesh-mat and a k-matrix in comsol format.

    fprintf(['solving for kxy=' num2str(kxy) ' and kz=' num2str(kz) '...\n']);
    % Application mode 1
    clear appl
    appl.mode.class = 'GeneralHeat';
    appl.module = 'HT';
    appl.shape = {'shlag(1,''J'')','shlag(2,''T'')'};
    appl.sshape = 2;
    appl.assignsuffix = '_htgh';
    clear bnd
    bnd.type = {'q0','cont'};
    bnd.shape = 1;
    bnd.ind = [1,1,1,1,2,2,2,2,2,1,1,1,1,2];
    appl.bnd = bnd;
    clear equ
    equ.sdtype = 'gls';
\end{minted}
\normalsize

Here, parameters or the material properties are attached to the domain:

\small
\begin{minted}{matlab}
    % densities
    equ.rho = {params.density_snow,params.density_needle};
    equ.init = 0;
    equ.shape = 2;
    % Heat capacities
    equ.C = {params.cp_snow,params.cp_needle};
    % Wattage
    equ.Q = {0,params.q_needle/pi/(params.rneedle)^2};
    % Heat conductivities
    arr = [cos(theta*pi/180), 0, sin(theta*pi/180); 0, 1, 0; -sin(theta*pi/180), 0, cos(theta*pi/180)]; %rotation matrix
    equ.k = {symmetric_tocell(arr*diag([kxy,kxy,kz])*(arr')),params.k_needle};
\end{minted}
\normalsize

This is also where the symmetric matrix is generated, as described in section
\ref{sec:numerical-np:domain}. ``symmetric_tocell'' is a helper function which
converts symmetric matrices of the form 
\minted{matlab}{[a1 a2 a4; a2 a3 a5; a4 a5 a6]} to the form
\minted{matlab}{ {a1, a2, a3, a4, a5, a6 }}.

Then, more code generated by COMSOL:

\small
\begin{minted}{matlab}
    equ.ind = [1,2];
    appl.equ = equ;
    fem.appl{1} = appl;
    fem.frame = {'ref'};
    fem.border = 1;
    fem.outform = 'general';
    clear units;
    units.basesystem = 'SI';
    fem.units = units;

    % Coupling variable elements
    clear elemcpl
    % Integration coupling variables
    clear elem
    elem.elem = 'elcplscalar';
    elem.g = {'1'};
    src = cell(1,1);
    clear bnd
    bnd.expr = {{'T',{}},{'1',{}}};
    bnd.ipoints = {{'4',{}},{'4',{}}};
    bnd.frame = {{'ref',{}},{'ref',{}}};
    bnd.ind = {{'1','2','3','4','10','11','12','13'},{'5','6','7','8','9', ...
      '14'}};
    src{1} = {{},{},bnd,{}};
    elem.src = src;
    geomdim = cell(1,1);
    geomdim{1} = {};
    elem.geomdim = geomdim;
    elem.var = {'int_T','area'};
    elem.global = {'1','2'};
    elemcpl{1} = elem;
    fem.elemcpl = elemcpl;

    % ODE Settings
    clear ode
    clear units;
    units.basesystem = 'SI';
    ode.units = units;
    fem.ode=ode;

    % Multiphysics
    fem=multiphysics(fem);

    % Generate GMG mesh cases
    fem=meshcaseadd(fem,'mgauto','anyshape');

    % Extend mesh
    fem.xmesh=meshextend(fem);

    % Solve problem
    fem.sol=femtime(fem, ...
                    'solcomp',{'T'}, ...
                    'outcomp',{'T'}, ...
                    'blocksize','auto', ...
                    'tlist', params.time, ...
                    'estrat',1, ...
                    'tout','tlist', ...
                    'linsolver','gmres', ...
                    'itrestart',100, ...
                    'prefuntype','right', ...
                    'prefun','gmg', ...
                    'prepar',{'presmooth','ssor','presmoothpar',{'iter',3,'relax',0.8},'postsmooth','ssor','postsmoothpar',{'iter',3,'relax',0.8},'csolver','pardiso'}, ...
                    'stopcond','0.06-int_T/area', ...
                    'mcase',[0 1]);

    % Save current fem structure for restart purposes
    fem0=fem;
\end{minted}
\normalsize

Code to plot the solution was commented out and replaced with code to save the
temperature data at the center of the needle, and the average temperature of the
six points at the surface of the sphere, to MATLAB variables:

\small
\begin{minted}{matlab}

    % Plot solution
    %{
    postplot(fem, ...
             'slicedata',{'T','cont','internal','unit','K'}, ...
             'slicexspacing',5, ...
             'sliceyspacing',0, ...
             'slicezspacing',0, ...
             'slicemap','Rainbow', ...
             'solnum','end', ...
             'title','Time=100    Slice: Temperature [K]', ...
             'grid','on', ...
             'campos',[-2.636014311828346,-3.4353207343472505,2.4999999999999996], ...
             'camtarget',[0,0,0], ...
             'camup',[0,0,1], ...
             'camva',41.213465344831754);
    %}

    % Integrate
    T_thermistor=postint(fem,'T', ...
               'unit','K', ...
               'recover','off', ...
               'dl',8, ...
               'edim',0, ...
               'solnum','all');

    % Integrate
    T_surf_avg=postint(fem,'T', ...
               'unit','', ...
               'recover','off', ...
               'dl',[1,2,3,4,10,11,12,13], ...
               'edim',2, ...
               'solnum','end');
\end{minted}
\normalsize

Finally, the data is packed into a cell array, and the ``angles'' parameter
is changed:

\small
\begin{minted}{matlab}

    answer={[fem.sol.tlist; T_thermistor],T_surf_avg};
    angles = params.angles(2:length(params.angles));

    %flsave(['fem-' num2str(theta) '-' num2str(kxy) '-' num2str(kz) '.mph']);

    save('angles.m', 'angles');
end
\end{minted}
\normalsize

In some runs, the fem structure was exported back to the COMSOL format for
further study.

\section{Automatic Calculation of Conductivity from Simulated Time/Temperature Data}

Results from COMSOL were automatically fitted against the linear model with
respect to \(\ln(t)\) by ``dropping'' early \((t,T)\) datapoints until the
correlation coefficient of the remaining points was sufficiently high. Then, a
linear curvefit was applied to these remaining points. Finally, the slope was
used to calculate \(k_{\textrm{meas}}\).

\small
\begin{minted}{matlab}
function k = fitter(t,T,rset,params)
    logt = log(t(t>1));
    T = T(t>1);

    disp('Finding linear portion...');    
    for i=1:length(logt)-1
        C = corrcoef(logt(i:length(logt)), T(i:length(T)));
        r = sqrt(C(2,1));
        if r > rset %adjust this to get 'good' values
            disp([ 'linear fitting to ' ...
                   num2str((length(logt)-i)) ...
                   ' points from t=' num2str(exp(logt(i))) ...
                   ' to t=' ...
                   num2str(exp(logt(length(logt)))) ...
                   '...']);
            x = polyfit(logt(i:length(logt)),T(i:length(T)), 1);
            break
        end
    end

    k = (params.q_needle)/(4*pi*x(1));
end
\end{minted}
\normalsize

\section{Organization and Serialization of Results}

Simulation results were saved in a .mat file, which is MATLAB's native
serialization format. Results were organized into a nested cell array which
mirrored the format of two MATLAB matrices k\_xy and k\_z:

These functions were called by ``worker.m,'' which was used to run multiple
tests and save the results.

%% WORKER %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\small
\begin{minted}{matlab}
%worker.m
%does the working

function worker(kxy,kz)
    load('angles.mat', 'angles');
    angles
    [kxy,kz] = meshgrid(kxy,kz);

    %flreport('off');

    params=struct('rsnow', 0.4, ...
                  'rneedle', 0.00025, ...
                  'lneedle', 0.1, ...
                  'density_snow', 200, ...
                  'density_needle', 8000, ...
                  'cp_snow', 2050, ...
                  'cp_needle', 460, ...
                  'q_needle', 0.5, ...
                  'k_needle', 160, ...
                  'time', [logspace(0.1,1,15) logspace(1,3,15)], ...
                  'angles', angles );

    saveroot=['./solutions-' date '/'];

    mesh = mesher(0,params);
    for angle=angles,
        try
            solutions = arrayfun(@(x,y) solver(x,y,mesh,angle,params), ...
                            kxy,kz, 'UniformOutput', false);
            save solutions
            fprintf('Fitting solutions...\n');
            solutions = {cellfun(@(tsd) {fitter(tsd{1}(1,:),tsd{1}(2,:), ...
                                             0.999,params), ...
                             tsd{1}, tsd{2}}, ...
                         solutions, 'UniformOutput', false)};
            fprintf('A solution set just completed.');
            system([ 'echo "A solution set finished on" `hostname` ' ...
                     '| mutt -s "A solution set completed." ' ...
                     'josh.holbrook@gmail.com' ]);
        catch exception
            system([ 'echo "Exception occurred on" `hostname` ' ...
                     '| mutt -s "Exception occurred--' exception.message ...
                     '" josh.holbrook@gmail.com' ]);
        end
        angles = angles(2:length(angles));
        save('angles.mat', 'angles');
        %solutions
        mkdir(saveroot);
        save([ saveroot 'solution-' num2str(angle) ], ...
             'solutions','angle','kxy','kz','params');
    end

    % Emails me when everything's done
    system([ 'echo "Results completed on " `hostname` ' ...
             '| mutt -s "Results Completed" ' ...
             'josh.holbrook@gmail.com' ]);
    system('touch down');
end
\end{minted}
\normalsize
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The data stored in each slot of the nested array was itself a cell array
containing the simulation results, as shown in figure \ref{fig:cellarray}:

% Bastardization of tabular use.
\begin{figure}
\label{fig:cellarray}

\centering
\begin{tabular}{| c | c | c |}
\hline
\(k_\textrm{meas}\) & \( \left[ \textrm{time}, \textrm{temperature} \right]^T\) & Average surface temperature of sphere\\
\hline
\end{tabular}
\caption{Contents of the cell array.}
\end{figure}

\section{Post-Simulation Analysis with MATLAB}

\section{Code Architecture and Use}

% \section{Verification with Analytical Approach}
