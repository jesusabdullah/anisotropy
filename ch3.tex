\chapter{Numerical Needle Probe Approach}
\label{sec:numerical-np}
\bigskip

\section{Introduction} 
\label{sec:numerical-np:introduction}

Numerical experiments simulated needle probes in anisotropic mediums with
three-dimensional finite element heat transfer models in COMSOL 3.5a. While the
models themselves were relatively simple, attempting to automate a parameter
study in COMSOL 3.5a with respect to the anisotropic material properties proved
difficult.

\section{Geometry and Domain Properties}

\begin{table}[h]
\label{tab:constants}
\centering
\caption{Constants Used in Numerical Models}
\begin{tabular}{r | l}
radius of needle & \(0.25\) mm\\
length of needle & \(10\) cm\\
radius of snow & \(40\) cm\\
\hline
density of needle & \(8000\) kg/\(\textrm{m}^3\)\\
\(C_P\) of needle & \(460\) \textbf{*units*}\\
\(q\) of needle & \(0.5\) W/m\\
\(k\) of needle & \(160\) \textbf{*units*}\\
\hline
density of snow & \(200\) kg/\(\textrm{m}^3\)\\
\(C_P\) of snow & \(2050\) \textbf{*units*}
\end{tabular}
\end{table}

The needle was simulated as a long, thin steel cylinder embedded in the center
of a sphere of snow. While most of the dimensions and material properties were
held constant (see Table \ref{tab:constants}), the anisotropic conductivity of
the snow was parameterized in the form of a \(3\times3\) symmetric, positive
definite matrix.  In practice, this was done by specifying a diagonal matrix
\(\Lambda\) with positive eigenvalues \(k_{xy}\) and \(k_z\) and a rotation
matrix \(R\) around the \(x\) axis, and then defining \(K = R^T\Lambda R\) as in
equation \ref{eq:rotdiagrot} :

\begin{equation}
\label{eq:rotdiagrot}
K = \begin{bmatrix}
\cos(\theta) & 0 & \sin(\theta)\\
0 & 1 & 0\\
-\sin(\theta) & 0 &\cos(\theta)
\end{bmatrix}
\begin{bmatrix}
k_{xy} & 0 & 0\\
0 & k_{xy} & 0\\
0 & 0 & k_z
\end{bmatrix}
\begin{bmatrix}
\cos(\theta) & 0 & \sin(\theta)\\
0 & 1 & 0\\
-\sin(\theta) & 0 &\cos(\theta)
\end{bmatrix}
\end{equation}

\section{Geometry-Based Parameter Studies Using COMSOL 3.5a}

Unfortunately, COMSOL 3.5a did not have the facilities necessary to implement a
geometry-changing multi-parameter study as required from the GUI alone. However,
COMSOL 3.5a did have facilities for scripting with MATLAB. Unfortunately, I
found the facility to be poorly-documented, and, at least with the particular
install hosted by ARSC, buggy and prone to crashing.

MATLAB code written to implement the parameter study was largely auto-generated
by COMSOL, by building a base model in COMSOL 3.5a and exporting to an m-file.
Much of the hand-written code was merely to handle errors and to allow saving
of completed studies during execution such that the data wouldn't be lost due to
a segmentation fault.

\small
\begin{minted}{matlab}
%worker.m
%does the working

function worker(kxy,kz)
    load('angles.mat', 'angles');
    angles
    [kxy,kz] = meshgrid(kxy,kz);

    %flreport('off');

    params=struct('rsnow', 0.4, ...
                  'rneedle', 0.00025, ...
                  'lneedle', 0.1, ...
                  'density_snow', 200, ...
                  'density_needle', 8000, ...
                  'cp_snow', 2050, ...
                  'cp_needle', 460, ...
                  'q_needle', 0.5, ...
                  'k_needle', 160, ...
                  'time', [logspace(0.1,1,15) logspace(1,3,15)], ...
                  'angles', angles );

    saveroot=['./solutions-' date '/'];

    mesh = mesher(0,params);
    for angle=angles,
        try
            solutions = arrayfun(@(x,y) solver(x,y,mesh,angle,params), ...
                            kxy,kz, 'UniformOutput', false);
            save solutions
            fprintf('Fitting solutions...\n');
            solutions = {cellfun(@(tsd) {fitter(tsd{1}(1,:),tsd{1}(2,:), ...
                                             0.999,params), ...
                             tsd{1}, tsd{2}}, ...
                         solutions, 'UniformOutput', false)};
            fprintf('A solution set just completed.');
            system([ 'echo "A solution set finished on" `hostname` ' ...
                     '| mutt -s "A solution set completed." ' ...
                     'josh.holbrook@gmail.com' ]);
        catch exception
            system([ 'echo "Exception occurred on" `hostname` ' ...
                     '| mutt -s "Exception occurred--' exception.message ...
                     '" josh.holbrook@gmail.com' ]);
        end
        angles = angles(2:length(angles));
        save('angles.mat', 'angles');
        %solutions
        mkdir(saveroot);
        save([ saveroot 'solution-' num2str(angle) ], ...
             'solutions','angle','kxy','kz','params');
    end

    % Emails me when everything's done
    system([ 'echo "Results completed on " `hostname` ' ...
             '| mutt -s "Results Completed" ' ...
             'josh.holbrook@gmail.com' ]);
    system('touch down');
end
\end{minted}
\normalsize

\section{Automatic Calculation of Conductivity from Simulated Time/Temperature Data}

\begin{verbatim}
Code here
\end{verbatim}

\section{Organization and Serialization of Results}

Simulation results were saved in a .mat file, which is MATLAB's native
serialization format. Results were organized into a nested cell array which
mirrored the format of two MATLAB matrices k\_xy and k\_z:

\begin{verbatim}
Show and explain code which cellfuns it up
\end{verbatim}

The data stored in each slot of the nested array was itself a cell array
containing the simulation results, as shown in figure \ref{fig:cellarray}:

% Bastardization of tabular use.
\begin{figure}
\label{fig:cellarray}

\centering
\begin{tabular}{| c | c | c |}
\hline
\(k_\textrm{meas}\) & \( \left[ \textrm{time}, \textrm{temperature} \right]^T\) & Average surface temperature of sphere\\
\hline
\end{tabular}
\caption{Contents of the cell array.}
\end{figure}

\section{Post-Simulation Analysis with MATLAB}

\section{Code Architecture and Use}

% \section{Verification with Analytical Approach}
